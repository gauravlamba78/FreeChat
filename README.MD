# FreeChat: Open-Source Low-Code Chat Platform with Docker, React, NGINX, PostgreSQL

[![Release](https://img.shields.io/badge/Release-v1.0.0-blue?logo=github)](https://github.com/gauravlamba78/FreeChat/releases) [![Docker](https://img.shields.io/badge/Docker-Ready-blue?logo=docker&logoColor=white)](https://docs.docker.com/) [![Frontend](https://img.shields.io/badge/Frontend-React%20%2B%20Tailwind-blue?logo=react&logoColor=61DAFB)](https://react.dev/) [![Backend](https://img.shields.io/badge/Backend-Node.js-blue?logo=node.js)](https://nodejs.org/) [![Server](https://img.shields.io/badge/NGINX-Proxy-blue?logo=nginx&logoColor=white)](https://nginx.org/)

<img alt="FreeChat banner" src="https://images.unsplash.com/photo-1515879218367-8466d910aaa4?auto=format&fit=crop&w=1400&q=60" width="100%">

This repository was created by Flatlogic Platform: https://flatlogic.com/generator

Welcome to FreeChat, an open-source, low-code friendly chat platform designed for teams who want fast setup, scalable architecture, and a clean user experience. The project blends modern frontend with a reliable backend, all wrapped in a Dockerized stack. Itâ€™s built to be approachable for new developers and robust enough for production workloads.

If you are here for the latest release, head to the Releases page for downloadables and update notes.

The main goal of this project is to provide a pleasant developer experience while offering a solid baseline for chat applications. Components are modular, tests are in place, and the codebase emphasizes readability and maintainability. Whether you want a small internal chat tool, a customer support chat, or a full-blown collaboration app, FreeChat is structured to adapt quickly.

Quick reference: this project centers on a Docker-driven stack with a Node.js backend, a React frontend styled with Tailwind, and an NGINX reverse proxy. PostgreSQL handles persistent data, while Docker Compose ties everything together. The result is a scalable, production-friendly foundation you can customize to fit your use case.

Table of Contents
- Project at a glance
- Why FreeChat
- Core features
- Tech stack
- Architecture overview
- Getting started
- Installation from Releases
- Development workflow
- Docker and deployment
- Data model and migrations
- Frontend design and theming
- Admin tools and configuration
- Security and compliance
- Performance and observability
- Testing and quality assurance
- Localization and accessibility
- CI/CD and automation
- Contribution and governance
- Roadmap
- FAQ
- License
- Acknowledgments

Project at a glance
- Repository name: FreeChat
- Primary purpose: A modern, low-code friendly chat platform with Dockerized services
- Main technologies: React, Tailwind, Node.js, PostgreSQL, NGINX
- Deployment model: Docker Compose by default, with production-ready tweaks for reverse proxy, TLS, and scalable storage
- Target users: Teams, startups, and developers who want a fast path to a chat application with a strong foundation

Why FreeChat
- Speed: Quick to spin up, quick to customize.
- Modularity: Clear boundaries between frontend, backend, and infrastructure.
- Observability: Built-in hooks for logging, metrics, and tracing.
- Security: Thoughtful defaults around authentication, data isolation, and secrets handling.
- Low-code friendliness: Clear extension points and sensible defaults to reduce boilerplate.
- Community-driven: Open to contributions and feedback from developers with diverse use cases.

Core features
- Real-time messaging with WebSocket support
- Rich message types: text, media previews, links, and emojis
- User presence and typing indicators
- Conversation threads and channel organization
- Searchable chat history with pagination
- User authentication with token-based security
- Role-based access and basic permissions
- Theming with Tailwind CSS and responsive design
- Admin console for users, rooms, and permissions
- Deployment-ready with containerization and a reverse proxy

Tech stack
- Frontend: React, Tailwind CSS, Vite (fast dev server)
- Backend: Node.js, Express (or a similar lightweight framework)
- Database: PostgreSQL
- Cache/Queue: Optional Redis for session storage and message queues
- Reverse proxy: NGINX
- Containerization: Docker and Docker Compose
- Source control: GitHub
- Observability: Structured logging, basic metrics
- Testing: Unit tests, integration tests, and end-to-end tests

Architecture overview
- Frontend client
  - Built with React and Tailwind
  - Communicates with the backend via REST and WebSocket channels
  - Thin, resilient UI that degrades gracefully in poor network conditions
- Backend services
  - API server handles authentication, message routing, and business logic
  - WebSocket service manages real-time communications
  - Data layer uses PostgreSQL with migrations and seeds
- Infrastructure
  - Docker Compose orchestrates services: frontend, backend, WebSocket gateway, database, and NGINX
  - NGINX handles TLS termination, load balancing, and static asset delivery
  - Persistent data stored in Docker volumes
- Security
  - Token-based authentication
  - Role-based access control
  - Secrets management via environment variables and protected storage
- Observability
  - Centralized logs and structured event data
  - Metrics endpoints for health and readiness

Getting started
- Prerequisites
  - Docker and Docker Compose installed
  - Basic knowledge of command-line operations
- Quick start (local development)
  - Clone the repository
  - Copy sample environment files
  - Start the stack with Docker Compose
  - Access the app in your browser
- Development workflow
  - Frontend: hot-reload, component-driven development
  - Backend: local API scaffold with test data
  - Admin console: quick prototyping for user and room management

Installation from Releases
- If you want a quick start from a published release, visit the Releases page
  - Release link: https://github.com/gauravlamba78/FreeChat/releases
- The asset for Linux users is named freechat-linux-x64.tar.gz
- File to download and execute: freechat-linux-x64.tar.gz
- Steps to install on Linux
  - Download the release asset named freechat-linux-x64.tar.gz from the Releases page
  - Open a terminal and run the following commands (adjust paths as needed):
    - tar -xzf freechat-linux-x64.tar.gz
    - cd freechat-linux-x64
    - chmod +x install.sh
    - ./install.sh
  - If you prefer a manual approach, you can inspect the install script to learn about the setup steps
- What you get from the release
  - A pre-configured binary or installer that sets up the required components
  - A baseline environment tailored for quick onboarding
  - Default configuration that you can customize post-install
- If you cannot locate the asset or the URL changes
  - Check the Releases section on the repository for the latest asset
  - If the asset is missing, use the Docker-based local setup described in this README

Development workflow
- Repository structure
  - frontend/ contains the React UI with Tailwind styling
  - backend/ contains the Node.js API and business logic
  - docker/ contains the Docker Compose files and configs
  - nginx/ contains the reverse proxy and TLS configuration
  - postgres/ contains schema and seed data
  - docs/ contains developer guides and API references
- Local development steps
  - Use Docker Compose to spin up all services
  - Open localhost URLs to access frontend and admin interfaces
  - Use the admin console to create test users and rooms
- Running tests
  - Unit tests live in the respective frontend and backend directories
  - End-to-end tests simulate user flows like login, messaging, and room switching
  - Linting ensures consistent code quality
- Debugging tips
  - Check container logs for errors
  - Verify environment variable values in the .env file
  - Confirm network connectivity between services in the Docker network
  - Use browser dev tools to inspect WebSocket activity and API responses

Docker and deployment
- Docker Compose overview
  - docker-compose.yml defines services: frontend, backend, db, redis (optional), and nginx
  - Volumes persist data and enable quick restarts without data loss
  - Networks isolate services while allowing controlled communication
- Environment and configuration
  - Use a .env file to configure database credentials, API keys, and secrets
  - Sensitive data should be kept out of version control
  - TLS is enabled in production with a dedicated certificate management approach
- High-level deployment steps
  - Build and run the stack with docker compose
  - Configure NGINX for TLS termination and reverse proxy routing
  - Initialize the database schema and seed data
  - Verify the frontend can reach the API and that real-time messaging works
- Docker tips
  - Use docker-compose up -d to start in detached mode
  - Use docker-compose logs -f to monitor logs
  - Use docker-compose down to stop and remove containers while preserving volumes if needed

Data model and migrations
- Core entities
  - User: represents a participant in chats
  - Conversation: a chat thread or channel
  - Message: stores content, timestamp, and sender
  - Channel/Room: sub-groupings within conversations
  - Presence: tracks online/offline status
- Migrations
  - Migrations ensure incremental changes to the PostgreSQL schema
  - Seed data provides a ready-to-use test environment
- Security considerations
  - Passwords are hashed with a strong algorithm
  - Tokens are time-limited and rotatable
  - Access controls enforce permissions on rooms and conversations

Frontend design and theming
- UI philosophy
  - Clean, accessible, responsive UI
  - Tailwind-based theming with a light/dark mode
  - Focus on readability and fast interactions
- Components
  - MessageList, MessageInput, UserAvatar, ChannelList, MemberBadge
  - AdminPanel for managing users and rooms
  - SettingsPanel for user preferences and theming
- Accessibility
  - Keyboard navigability for core interactions
  - Clear color contrast and ARIA labels
  - Screen-reader friendly elements and readable typography
- Theming strategy
  - Palette configuration in a single source of truth
  - Theming hooks for runtime theme switching

Admin tools and configuration
- Admin console features
  - User management: create, edit, deactivate users
  - Channel management: create rooms, set permissions
  - Moderation: basic controls for messages and users
  - Audit log: track important actions
- Configuration options
  - Environment-driven defaults for security, rate limits, and feature toggles
  - Customizable branding, logos, and color schemes
- Data governance
  - Export/import options for backups
  - Role-based access checks to protect sensitive actions

Security and compliance
- Authentication
  - Token-based authentication with expiry and refresh
  - Passwordless options can be added with OTP or magic links
- Access control
  - Roles include admin, moderator, member, and guest
  - Fine-grained permissions on channels and conversations
- Data protection
  - Encrypted connections via TLS
  - Secrets managed through environment variables and secret stores
- Incident readiness
  - Structured logging to facilitate incident response
  - Health checks and readiness probes for container orchestration

Performance and observability
- Performance considerations
  - Efficient data access patterns for messages and presence
  - Caching to reduce load on the database for hot reads
- Observability
  - Centralized logging for frontend and backend
  - Metrics exposed for health, readiness, and key operations
  - Simple dashboards to monitor chat activity, error rates, and latency
- Scaling guidance
  - Stateless frontend components allow horizontal scaling
  - Backend services can scale with a dedicated API gateway
  - PostgreSQL scaling considerations include read replicas and connection pooling

Testing and quality assurance
- Test layers
  - Unit tests for backend APIs and frontend components
  - Integration tests for API endpoints and data flows
  - End-to-end tests that cover login, messaging, and presence
- Test data
  - Seed data ensures repeatable test scenarios
  - Anonymized data for privacy and compliance
- Quality gates
  - Linting and formatting checks
  - CI pipelines enforce tests before merging

Localization and accessibility
- Localization
  - Text resources prepared for multiple locales
  - Easy harness for translating UI strings
- Accessibility
  - Semantic HTML and ARIA roles
  - Focus management in modals and dialogs
  - Clear focus indicators for keyboard users

CI/CD and automation
- GitHub Actions (example)
  - Lint and format checks on pull requests
  - Automated tests on push to main
  - Builder workflow to produce release assets
  - Docker image build and push to a registry on release
- Deployment automation
  - Infrastructure as code patterns for provisioning environments
  - Staged deployments with blue-green or canary strategies
  - Rollback mechanisms for failed deployments
- Security automation
  - Dependency checks and vulnerability scans
  - Secrets scanning and drift detection

Contribution and governance
- How to contribute
  - Fork the repository, create a feature branch, and open a PR
  - Follow the coding style and run tests locally
  - Include clear descriptions and acceptance criteria
- Code style
  - Consistent naming conventions
  - Clear and concise comments for complex logic
- Review process
  - Maintainers review PRs for quality and impact
  - CI runs must pass before merging
- Community standards
  - Respectful communication and constructive feedback
  - Documentation improvements are welcome

Roadmap
- Short-term goals
  - Hardened deployment in production-like environments
  - Expanded test suite with end-to-end tests
  - Enhanced admin controls and analytics
- Medium-term goals
  - Multi-tenant support and per-server isolation
  - Advanced moderation tools and reporting
  - Performance optimization for large chat volumes
- Long-term vision
  - Open integrations with popular chat platforms
  - More low-code capabilities to customize workflows
  - A polished marketplace for plugins and themes

FAQ
- How do I start a local development environment?
  - Use Docker Compose to bring up frontend, backend, and database locally. See the Getting Started section for detailed commands.
- Can I customize the UI theme?
  - Yes. Tailwind-based theming is designed for easy customization, and branding assets are centralized.
- Is data persisted across restarts?
  - Yes, Docker volumes ensure data persists. Backups are recommended for production deployments.
- How do I migrate the database schema?
  - Migrations are included. Run the migration tool as part of your startup sequence or during upgrade.
- Where can I report issues?
  - Open issues on the repository. Include steps to reproduce and expected versus actual results.

License
- This project is licensed under the MIT License. See the LICENSE file for details.

Acknowlegements
- Hat tip to Flatlogic Platform for providing guidelines and tooling inspiration: https://flatlogic.com/generator
- Community contributors who helped shape the project

Contact
- For questions or collaboration, reach out via the repository's issues page or the project maintainers.

Topics
- docker
- flatlogic
- js
- low-code
- nginx
- nodejs
- postgresql
- react
- tailwind
- ts

Releases and asset notice
- For the latest updates and to download binaries or installers, visit the Releases page: https://github.com/gauravlamba78/FreeChat/releases
- If you are upgrading, please review the release notes and migration guidance carefully to minimize downtime. The asset named freechat-linux-x64.tar.gz is provided for Linux users and should be downloaded and executed as described in the Release assets section.

Note on asset download
- The asset named freechat-linux-x64.tar.gz is intended for Linux deployments. You should download and extract the asset, then run the included installer script. If you use a different platform, refer to the platform-specific instructions in the releases notes and the Docker-based setup described earlier in this document. For any questions about assets, check the Releases section and the documentation in docs/.

End of document.